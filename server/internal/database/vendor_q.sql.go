// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: vendor_q.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addVendor = `-- name: AddVendor :exec
INSERT INTO vendors (user_id,
                     full_name,
                     email,
                     phone_number,
                     store_name,
                     description,
                     address,
                     banner,
                     created_by,
                     updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type AddVendorParams struct {
	UserID      uuid.UUID
	FullName    string
	Email       string
	PhoneNumber string
	StoreName   string
	Description sql.NullString
	Address     string
	Banner      string
	CreatedBy   uuid.NullUUID
	UpdatedBy   uuid.NullUUID
}

func (q *Queries) AddVendor(ctx context.Context, arg AddVendorParams) error {
	_, err := q.db.ExecContext(ctx, addVendor,
		arg.UserID,
		arg.FullName,
		arg.Email,
		arg.PhoneNumber,
		arg.StoreName,
		arg.Description,
		arg.Address,
		arg.Banner,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const getAllVendors = `-- name: GetAllVendors :many
SELECT id, user_id, full_name, email, phone_number, store_name, status, description, address, banner, created_at, updated_at, created_by, updated_by
FROM vendors
WHERE
    ($1::vendors_status = 'null' OR status = $1)
  AND (store_name ILIKE '%' || $2::text || '%' OR $2 = '')
  AND (full_name ILIKE '%' || $3::text || '%' OR $3 = '')
  AND (address ILIKE '%' || $4::text || '%' OR $4 = '')
  AND (description ILIKE '%' || $5::text || '%' OR $5 = '')
ORDER BY created_at DESC
`

type GetAllVendorsParams struct {
	Column1 VendorsStatus
	Column2 string
	Column3 string
	Column4 string
	Column5 string
}

func (q *Queries) GetAllVendors(ctx context.Context, arg GetAllVendorsParams) ([]Vendor, error) {
	rows, err := q.db.QueryContext(ctx, getAllVendors,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vendor
	for rows.Next() {
		var i Vendor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FullName,
			&i.Email,
			&i.PhoneNumber,
			&i.StoreName,
			&i.Status,
			&i.Description,
			&i.Address,
			&i.Banner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVendorById = `-- name: GetVendorById :one
SELECT
    vendors.id AS vendor_id,
    vendors.full_name AS vendor_full_name,
    vendors.email AS vendor_email,
    vendors.phone_number,
    vendors.store_name,
    vendors.status,
    vendors.description,
    vendors.address,
    vendors.banner,
    vendors.created_at,
    vendors.updated_at,
    vendors.created_by,
    vendors.updated_by,
    vendors.user_id,
    users.full_name AS user_full_name,
    users.avt AS user_avatar,
    users.email AS user_email
FROM
    vendors
        JOIN
    users ON vendors.user_id = users.id
WHERE
    vendors.id = $1
`

type GetVendorByIdRow struct {
	VendorID       uuid.UUID
	VendorFullName string
	VendorEmail    string
	PhoneNumber    string
	StoreName      string
	Status         NullVendorsStatus
	Description    sql.NullString
	Address        string
	Banner         string
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	CreatedBy      uuid.NullUUID
	UpdatedBy      uuid.NullUUID
	UserID         uuid.UUID
	UserFullName   sql.NullString
	UserAvatar     sql.NullString
	UserEmail      string
}

func (q *Queries) GetVendorById(ctx context.Context, id uuid.UUID) (GetVendorByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getVendorById, id)
	var i GetVendorByIdRow
	err := row.Scan(
		&i.VendorID,
		&i.VendorFullName,
		&i.VendorEmail,
		&i.PhoneNumber,
		&i.StoreName,
		&i.Status,
		&i.Description,
		&i.Address,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.UserID,
		&i.UserFullName,
		&i.UserAvatar,
		&i.UserEmail,
	)
	return i, err
}

const getVendorByUUID = `-- name: GetVendorByUUID :one
SELECT id, user_id, full_name, email, phone_number, store_name, status, description, address, banner, created_at, updated_at, created_by, updated_by
FROM vendors
WHERE user_id = $1
`

func (q *Queries) GetVendorByUUID(ctx context.Context, userID uuid.UUID) (Vendor, error) {
	row := q.db.QueryRowContext(ctx, getVendorByUUID, userID)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FullName,
		&i.Email,
		&i.PhoneNumber,
		&i.StoreName,
		&i.Status,
		&i.Description,
		&i.Address,
		&i.Banner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateVendorStatus = `-- name: UpdateVendorStatus :exec
UPDATE vendors
SET status = $1, updated_by = $2
WHERE user_id = $3
`

type UpdateVendorStatusParams struct {
	Status    NullVendorsStatus
	UpdatedBy uuid.NullUUID
	UserID    uuid.UUID
}

func (q *Queries) UpdateVendorStatus(ctx context.Context, arg UpdateVendorStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateVendorStatus, arg.Status, arg.UpdatedBy, arg.UserID)
	return err
}
