// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products_q.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const addProduct = `-- name: AddProduct :one
INSERT INTO products (
    name,
    slug,
    images,
    vendor_id,
    category_id,
    sub_category_id,
    child_category_id,
    short_description,
    long_description,
    product_type,
    status,
    is_approved
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, created_at, updated_at
`

type AddProductParams struct {
	Name             string
	Slug             string
	Images           json.RawMessage
	VendorID         uuid.UUID
	CategoryID       uuid.UUID
	SubCategoryID    uuid.NullUUID
	ChildCategoryID  uuid.NullUUID
	ShortDescription sql.NullString
	LongDescription  sql.NullString
	ProductType      sql.NullString
	Status           NullProductStatus
	IsApproved       sql.NullBool
}

type AddProductRow struct {
	ID        uuid.UUID
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

func (q *Queries) AddProduct(ctx context.Context, arg AddProductParams) (AddProductRow, error) {
	row := q.db.QueryRowContext(ctx, addProduct,
		arg.Name,
		arg.Slug,
		arg.Images,
		arg.VendorID,
		arg.CategoryID,
		arg.SubCategoryID,
		arg.ChildCategoryID,
		arg.ShortDescription,
		arg.LongDescription,
		arg.ProductType,
		arg.Status,
		arg.IsApproved,
	)
	var i AddProductRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    id,
    name,
    slug,
    images,
    vendor_id,
    category_id,
    sub_category_id,
    child_category_id,
    short_description,
    long_description,
    product_type,
    status,
    is_approved,
    created_at,
    updated_at
FROM products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Images,
		&i.VendorID,
		&i.CategoryID,
		&i.SubCategoryID,
		&i.ChildCategoryID,
		&i.ShortDescription,
		&i.LongDescription,
		&i.ProductType,
		&i.Status,
		&i.IsApproved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.name,
    p.slug,
    p.images,
    p.vendor_id,
    p.category_id,
    p.sub_category_id,
    p.child_category_id,
    p.short_description,
    p.long_description,
    p.product_type,
    p.status,
    p.is_approved,
    p.created_at,
    p.updated_at,
    v.store_name,
    c.name AS category_name
FROM products p
    LEFT JOIN vendors v ON p.vendor_id = v.id
    LEFT JOIN categories c ON p.category_id = c.id
WHERE
    (v.store_name ILIKE '%' || COALESCE($1, '') || '%' OR $1 IS NULL) AND
    (p.name ILIKE '%' || COALESCE($2, '') || '%' OR $2 IS NULL) AND
    (p.product_type ILIKE '%' || COALESCE($3, '') || '%' OR $3 IS NULL) AND
    (p.status = COALESCE($4, p.status) OR $4 IS NULL)
ORDER BY p.updated_at DESC
`

type ListProductsParams struct {
	Column1 sql.NullString
	Column2 sql.NullString
	Column3 sql.NullString
	Status  NullProductStatus
}

type ListProductsRow struct {
	ID               uuid.UUID
	Name             string
	Slug             string
	Images           json.RawMessage
	VendorID         uuid.UUID
	CategoryID       uuid.UUID
	SubCategoryID    uuid.NullUUID
	ChildCategoryID  uuid.NullUUID
	ShortDescription sql.NullString
	LongDescription  sql.NullString
	ProductType      sql.NullString
	Status           NullProductStatus
	IsApproved       sql.NullBool
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	StoreName        sql.NullString
	CategoryName     sql.NullString
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Images,
			&i.VendorID,
			&i.CategoryID,
			&i.SubCategoryID,
			&i.ChildCategoryID,
			&i.ShortDescription,
			&i.LongDescription,
			&i.ProductType,
			&i.Status,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StoreName,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
    name = $2,
    slug = $3,
    images = $4,
    vendor_id = $5,
    category_id = $6,
    sub_category_id = $7,
    child_category_id = $8,
    short_description = $9,
    long_description = $10,
    product_type = $11,
    status = $12,
    is_approved = $13
WHERE id = $1
`

type UpdateProductParams struct {
	ID               uuid.UUID
	Name             string
	Slug             string
	Images           json.RawMessage
	VendorID         uuid.UUID
	CategoryID       uuid.UUID
	SubCategoryID    uuid.NullUUID
	ChildCategoryID  uuid.NullUUID
	ShortDescription sql.NullString
	LongDescription  sql.NullString
	ProductType      sql.NullString
	Status           NullProductStatus
	IsApproved       sql.NullBool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Images,
		arg.VendorID,
		arg.CategoryID,
		arg.SubCategoryID,
		arg.ChildCategoryID,
		arg.ShortDescription,
		arg.LongDescription,
		arg.ProductType,
		arg.Status,
		arg.IsApproved,
	)
	return err
}
