// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products_q.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const addProduct = `-- name: AddProduct :one
INSERT INTO products (
    name,
    slug,
    images,
    vendor_id,
    category_id,
    sub_category_id,
    child_category_id,
    short_description,
    long_description,
    product_type,
    status,
    is_approved
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, created_at, updated_at
`

type AddProductParams struct {
	Name             string
	Slug             string
	Images           json.RawMessage
	VendorID         uuid.UUID
	CategoryID       uuid.UUID
	SubCategoryID    uuid.NullUUID
	ChildCategoryID  uuid.NullUUID
	ShortDescription sql.NullString
	LongDescription  sql.NullString
	ProductType      sql.NullString
	Status           NullProductStatus
	IsApproved       sql.NullBool
}

type AddProductRow struct {
	ID        uuid.UUID
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

func (q *Queries) AddProduct(ctx context.Context, arg AddProductParams) (AddProductRow, error) {
	row := q.db.QueryRowContext(ctx, addProduct,
		arg.Name,
		arg.Slug,
		arg.Images,
		arg.VendorID,
		arg.CategoryID,
		arg.SubCategoryID,
		arg.ChildCategoryID,
		arg.ShortDescription,
		arg.LongDescription,
		arg.ProductType,
		arg.Status,
		arg.IsApproved,
	)
	var i AddProductRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getFlashSaleProductNow = `-- name: GetFlashSaleProductNow :many
SELECT f.id, f.flash_sales_id, f.product_id, f.show, f.created_at, f.updated_at,
       p.id,
       p.name,
       p.slug,
       p.images,
       p.vendor_id,
       p.category_id,
       p.sub_category_id,
       p.child_category_id,
       p.short_description,
       p.long_description,
       p.product_type,
       p.status,
       p.is_approved,
       p.created_at,
       p.updated_at,
       v.store_name,
       c.name AS category_name,
       sc.name AS sub_category_name,
       cc.name AS child_category_name
FROM flash_sales_items f
    INNER JOIN flash_sales fl ON f.flash_sales_id = fl.id
    INNER JOIN products p ON f.product_id = p.id
    INNER JOIN vendors v ON p.vendor_id = v.id
    INNER JOIN categories c ON p.category_id = c.id
    LEFT JOIN sub_categories sc ON sc.id = p.sub_category_id
    LEFT JOIN child_categories cc ON cc.id = p.child_category_id
WHERE fl.start_date <= CURRENT_TIMESTAMP AND fl.end_date >= CURRENT_TIMESTAMP
    AND (show = $1 OR $1 IS NULL)
`

type GetFlashSaleProductNowRow struct {
	ID                uuid.UUID
	FlashSalesID      uuid.UUID
	ProductID         uuid.UUID
	Show              sql.NullBool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	ID_2              uuid.UUID
	Name              string
	Slug              string
	Images            json.RawMessage
	VendorID          uuid.UUID
	CategoryID        uuid.UUID
	SubCategoryID     uuid.NullUUID
	ChildCategoryID   uuid.NullUUID
	ShortDescription  sql.NullString
	LongDescription   sql.NullString
	ProductType       sql.NullString
	Status            NullProductStatus
	IsApproved        sql.NullBool
	CreatedAt_2       sql.NullTime
	UpdatedAt_2       sql.NullTime
	StoreName         string
	CategoryName      string
	SubCategoryName   sql.NullString
	ChildCategoryName sql.NullString
}

func (q *Queries) GetFlashSaleProductNow(ctx context.Context, show sql.NullBool) ([]GetFlashSaleProductNowRow, error) {
	rows, err := q.db.QueryContext(ctx, getFlashSaleProductNow, show)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlashSaleProductNowRow
	for rows.Next() {
		var i GetFlashSaleProductNowRow
		if err := rows.Scan(
			&i.ID,
			&i.FlashSalesID,
			&i.ProductID,
			&i.Show,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.Slug,
			&i.Images,
			&i.VendorID,
			&i.CategoryID,
			&i.SubCategoryID,
			&i.ChildCategoryID,
			&i.ShortDescription,
			&i.LongDescription,
			&i.ProductType,
			&i.Status,
			&i.IsApproved,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.StoreName,
			&i.CategoryName,
			&i.SubCategoryName,
			&i.ChildCategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    id,
    name,
    slug,
    images,
    vendor_id,
    category_id,
    sub_category_id,
    child_category_id,
    short_description,
    long_description,
    product_type,
    status,
    is_approved,
    created_at,
    updated_at
FROM products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Images,
		&i.VendorID,
		&i.CategoryID,
		&i.SubCategoryID,
		&i.ChildCategoryID,
		&i.ShortDescription,
		&i.LongDescription,
		&i.ProductType,
		&i.Status,
		&i.IsApproved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.name,
    p.slug,
    p.images,
    p.vendor_id,
    p.category_id,
    p.sub_category_id,
    p.child_category_id,
    p.short_description,
    p.long_description,
    p.product_type,
    p.status,
    p.is_approved,
    p.created_at,
    p.updated_at,
    v.store_name,
    c.name AS category_name,
    sc.name AS sub_category_name,
    cc.name AS child_category_name
FROM products p
    LEFT JOIN vendors v ON p.vendor_id = v.id
    LEFT JOIN categories c ON p.category_id = c.id
    LEFT JOIN sub_categories sc ON sc.id = p.sub_category_id
    LEFT JOIN child_categories cc ON cc.id = p.child_category_id
WHERE
    (v.store_name ILIKE '%' || COALESCE($1, '') || '%' OR $1 IS NULL) AND
    (p.name ILIKE '%' || COALESCE($2, '') || '%' OR $2 IS NULL) AND
    (p.product_type ILIKE '%' || COALESCE($3, '') || '%' OR $3 IS NULL) AND
    (p.status = COALESCE($4, p.status) OR $4 IS NULL) AND
    (p.vendor_id = COALESCE(NULLIF($5::text, '')::UUID, p.vendor_id) OR $5 IS NULL) AND
    (c.name ILIKE '%' || COALESCE($6, '') || '%' OR $6 IS NULL ) AND
    (p.is_approved = COALESCE($7, p.is_approved) OR $7 IS NULL) AND
    (sc.name ILIKE '%' || COALESCE($8, '') || '%' OR $8 IS NULL) AND
    (cc.name ILIKE '%' || COALESCE($9, '') || '%' OR $9 IS NULL)
ORDER BY p.updated_at DESC
`

type ListProductsParams struct {
	Column1    sql.NullString
	Column2    sql.NullString
	Column3    sql.NullString
	Status     NullProductStatus
	Column5    string
	Column6    sql.NullString
	IsApproved sql.NullBool
	Column8    sql.NullString
	Column9    sql.NullString
}

type ListProductsRow struct {
	ID                uuid.UUID
	Name              string
	Slug              string
	Images            json.RawMessage
	VendorID          uuid.UUID
	CategoryID        uuid.UUID
	SubCategoryID     uuid.NullUUID
	ChildCategoryID   uuid.NullUUID
	ShortDescription  sql.NullString
	LongDescription   sql.NullString
	ProductType       sql.NullString
	Status            NullProductStatus
	IsApproved        sql.NullBool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	StoreName         sql.NullString
	CategoryName      sql.NullString
	SubCategoryName   sql.NullString
	ChildCategoryName sql.NullString
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Status,
		arg.Column5,
		arg.Column6,
		arg.IsApproved,
		arg.Column8,
		arg.Column9,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Images,
			&i.VendorID,
			&i.CategoryID,
			&i.SubCategoryID,
			&i.ChildCategoryID,
			&i.ShortDescription,
			&i.LongDescription,
			&i.ProductType,
			&i.Status,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StoreName,
			&i.CategoryName,
			&i.SubCategoryName,
			&i.ChildCategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
    name = $2,
    slug = $3,
    images = $4,
    vendor_id = $5,
    category_id = $6,
    sub_category_id = $7,
    child_category_id = $8,
    short_description = $9,
    long_description = $10,
    product_type = $11,
    status = $12,
    is_approved = $13
WHERE id = $1
`

type UpdateProductParams struct {
	ID               uuid.UUID
	Name             string
	Slug             string
	Images           json.RawMessage
	VendorID         uuid.UUID
	CategoryID       uuid.UUID
	SubCategoryID    uuid.NullUUID
	ChildCategoryID  uuid.NullUUID
	ShortDescription sql.NullString
	LongDescription  sql.NullString
	ProductType      sql.NullString
	Status           NullProductStatus
	IsApproved       sql.NullBool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Images,
		arg.VendorID,
		arg.CategoryID,
		arg.SubCategoryID,
		arg.ChildCategoryID,
		arg.ShortDescription,
		arg.LongDescription,
		arg.ProductType,
		arg.Status,
		arg.IsApproved,
	)
	return err
}

const viewFullDetailOfProduct = `-- name: ViewFullDetailOfProduct :one
SELECT p.id, p.name, p.long_description, p.images, p.vendor_id, p.short_description,
       v.store_name, v.full_name AS vendor_full_name, v.phone_number, v.description AS vendor_description,
       v.address AS vendor_address, v.banner AS vendor_banner, v.email,
       c.name AS category_name,
       JSON_AGG(DISTINCT pv.name) AS variants,

       JSON_AGG(
           JSON_BUILD_OBJECT(
                pv.name, vo.name
            )
       ) AS options
FROM products p
INNER JOIN product_variants pv ON pv.product_id = p.id
INNER JOIN variant_options vo ON vo.product_variant_id = pv.id
INNER JOIN vendors v ON p.vendor_id = v.id
INNER JOIN categories c ON p.category_id = c.id
WHERE p.slug = $1
GROUP BY p.id, p.name, p.long_description, p.images, p.vendor_id, p.short_description,
v.store_name, v.full_name, v.phone_number, v.description, v.address, v.banner, v.email,
c.name
`

type ViewFullDetailOfProductRow struct {
	ID                uuid.UUID
	Name              string
	LongDescription   sql.NullString
	Images            json.RawMessage
	VendorID          uuid.UUID
	ShortDescription  sql.NullString
	StoreName         string
	VendorFullName    string
	PhoneNumber       string
	VendorDescription sql.NullString
	VendorAddress     string
	VendorBanner      string
	Email             string
	CategoryName      string
	Variants          json.RawMessage
	Options           json.RawMessage
}

func (q *Queries) ViewFullDetailOfProduct(ctx context.Context, slug string) (ViewFullDetailOfProductRow, error) {
	row := q.db.QueryRowContext(ctx, viewFullDetailOfProduct, slug)
	var i ViewFullDetailOfProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LongDescription,
		&i.Images,
		&i.VendorID,
		&i.ShortDescription,
		&i.StoreName,
		&i.VendorFullName,
		&i.PhoneNumber,
		&i.VendorDescription,
		&i.VendorAddress,
		&i.VendorBanner,
		&i.Email,
		&i.CategoryName,
		&i.Variants,
		&i.Options,
	)
	return i, err
}
